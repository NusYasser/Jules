import os
import tkinter as tk
from tkinter import filedialog
from PIL import Image
import pytesseract
import pandas as pd
from tqdm import tqdm
import re

# --- CONFIGURATION ---

# If Tesseract is not in your system's PATH, you need to set the command here.
# For example, on Windows, it might be:
# pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'

# List of keywords to identify a designation line. Case-insensitive.
# You can add more keywords here if you find common titles that are missed.
DESIGNATION_KEYWORDS = [
    'manager', 'director', 'lead', 'head', 'engineer', 'consultant', 'architect',
    'specialist', 'vp', 'svp', 'ceo', 'cto', 'cfo', 'coo', 'owner', 'officer',
    'analyst', 'advisor', 'administrator', 'strategy', 'developer', 'practice head',
    'sme', 'product owner', 'services', 'solutions', 'technical program',
    'founder', 'president', 'vice president', 'associate', 'executive', 'partner',
    'principal', 'senior', 'junior', 'staff', 'marketing', 'sales', 'hr',
    'human resources', 'finance', 'operations', 'project', 'program', 'talent',
    'recruit', 'recruitment', 'account', 'client', 'customer', 'tech', 'software',
    'hardware', 'research', 'development', 'salesforce', 'cloud', 'data', 'ai', 'ml',
    'avp', 'evp'
]

# Optional: Add keywords that commonly appear in company names but rarely in designations.
# This can help differentiate between a company and a second line of designation.
COMPANY_INDICATORS = [
    'inc.', 'llc', 'corp.', 'ltd.', 'group', 'solutions', 'technologies',
    'systems', 'company', 'co.', 'industries', 'global', 'international',
    'consulting', 'ventures', 'partners', 'associates', 'agency', 'institute',
    'university', 'school', 'hospital', 'bank', 'capital', 'fund', 'advisory',
    'media', 'digital', 'analytics', 'network', 'health', 'services', 'lab', 'labs',
    'corp', 'limited', 'inc', 'llc', 'pte ltd', 'plc', 's.a.', 'gmbh', 'ag', 'pvt', # Added more common company suffixes
    'llp'
]

def clean_text(text):
    """
    Cleans the extracted text by removing unreadable characters and excessive whitespace.
    Retains special characters that might be part of a name (e.g., hyphens, apostrophes).
    """
    # Allowed characters: letters, numbers, spaces, and common name/company special chars: .,&@#\'-
    text = re.sub(r'[^a-zA-Z0-9\s.,&@#\'-]', '', text)
    text = re.sub(r'\s+', ' ', text).strip() # Replace multiple spaces with a single space
    # Remove single characters that are not 'I' or 'A' and are not part of a word boundary
    text = re.sub(r'\b(?![IA])\w\b', '', text).strip()
    return text

def select_paths():
    """Opens GUI dialogs for user to select input and output paths."""
    root = tk.Tk()
    root.withdraw()  # Hide the main tkinter window

    print("A dialog box will open to select the FOLDER with your screenshots.")
    input_dir = filedialog.askdirectory(title="Select the Folder Containing Your Screenshots")
    if not input_dir:
        print("No input folder selected. Exiting.")
        return None, None

    print("A dialog box will open to select the SAVE LOCATION for the Excel file.")
    output_path = filedialog.asksaveasfilename(
        title="Save Excel File As...",
        defaultextension=".xlsx",
        filetypes=[("Excel Files", "*.xlsx"), ("All files", "*.*")]
    )
    if not output_path:
        print("No output file selected. Exiting.")
        return None, None
        
    return input_dir, output_path

def is_designation(line):
    """Checks if a line likely contains a job title."""
    cleaned_line = line.lower()
    return any(keyword in cleaned_line for keyword in DESIGNATION_KEYWORDS) and len(line) > 3

def is_company_likely(line):
    """Checks if a line likely contains a company name based on indicators and capitalization.
       This function is primarily for identifying the company *after* a designation."""
    cleaned_line = line.lower()
    # Check for company specific keywords
    if any(indicator in cleaned_line for indicator in COMPANY_INDICATORS):
        return True
    
    # Heuristic: Check if line starts with a capital letter and has multiple capitalized words
    # and doesn't look like a common short name (e.g., "John Doe")
    words = line.split()
    
    # If the line is short (1-2 words) and looks like a typical capitalized name, it's probably not a company.
    if len(words) <= 2 and all(word.istitle() for word in words if word and word.isalpha()):
        return False
        
    # For longer lines or lines with different capitalization patterns, apply broader checks
    if len(words) > 1 and (words[0].isupper() or words[0].istitle()): # Starts with Capital or Title
        capitalized_words_count = sum(1 for word in words if word and (word[0].isupper() or word.istitle()))
        # If a significant portion of words are capitalized and it's not a designation
        if capitalized_words_count >= len(words) * 0.5 and not is_designation(line):
            return True
            
    return False


def parse_ocr_text(text):
    records = []
    lines = [clean_text(line) for line in text.split('\n') if clean_text(line)]

    idx = 0
    while idx < len(lines):
        current_line_text = lines[idx]
        
        name = ""
        designation_parts = []
        company = ""
        
        # Step 1: Check if current line is a designation
        if is_designation(current_line_text):
            # Potential designation found.
            # Step 1a: Try to get a name from the previous line.
            if idx > 0:
                potential_name_line = lines[idx-1]
                # A name should not be a designation or a company indicator.
                if not is_designation(potential_name_line) and                    not any(indicator in potential_name_line.lower() for indicator in COMPANY_INDICATORS):
                    name = potential_name_line

            if not name: # Rule: If no valid name before designation, skip.
                idx += 1
                continue

            # Current line is the first part of the designation
            designation_parts.append(current_line_text.replace('>', '').strip())

            # Index used to track lines consumed for the current potential record
            # Starts at the first line of designation
            current_record_last_line_idx = idx

            # Step 1b: Check if the next line is a second part of the designation.
            if current_record_last_line_idx + 1 < len(lines):
                next_line_text = lines[current_record_last_line_idx + 1]
                # If next line is a designation AND not likely a company, it's part 2 of designation.
                if is_designation(next_line_text) and not is_company_likely(next_line_text):
                    designation_parts.append(next_line_text.replace('>', '').strip())
                    current_record_last_line_idx += 1 # Advance to the second designation line

                    # Step 1c: Company should be after the two-line designation.
                    if current_record_last_line_idx + 1 < len(lines):
                        potential_company_line = lines[current_record_last_line_idx + 1]
                        # Take as company if it's likely a company OR simply not another designation.
                        if is_company_likely(potential_company_line) or not is_designation(potential_company_line):
                            company = clean_text(potential_company_line)
                            current_record_last_line_idx += 1 # Advance to company line
                # Else (next line is not a second designation part), check if it's a company (for single-line designation)
                elif is_company_likely(next_line_text) or not is_designation(next_line_text):
                    company = clean_text(next_line_text)
                    current_record_last_line_idx += 1 # Advance to company line

            final_designation = " ".join(designation_parts)

            # Rule: Only add record if Name, Designation, AND Company are all present and non-empty.
            if name and final_designation and company:
                records.append((name, final_designation, company))

            # Advance main loop counter 'idx' to the line AFTER all consumed parts of the current record attempt.
            idx = current_record_last_line_idx + 1
            continue # Continue to next iteration of the while loop with the new idx

        # If current line is not a designation, simply advance
        idx += 1
            
    return records


def main():
    """Main function to run the entire process."""
    print("--- Screenshot to Excel Extractor ---")
    
    input_dir, output_path = select_paths()
    if not input_dir or not output_path:
        return

    print(f"\n[INFO] Input folder: {input_dir}")
    print(f"[INFO] Output file: {output_path}\n")

    # Get a list of all supported image files in the directory
    image_files = [
        f for f in os.listdir(input_dir) 
        if f.lower().endswith(('.png', '.jpg', '.jpeg', '.tiff', '.bmp'))
    ]

    if not image_files:
        print("[ERROR] No image files found in the selected directory. Exiting.")
        return

    all_data = []
    
    print(f"[INFO] Found {len(image_files)} images to process. This may take a while...")

    # Process each image file with a progress bar
    for filename in tqdm(image_files, desc="Processing Images"):
        try:
            image_path = os.path.join(input_dir, filename)
            
            # Use pytesseract to do OCR on the image
            raw_text = pytesseract.image_to_string(Image.open(image_path))
            
            # Parse the extracted text to find records
            records = parse_ocr_text(raw_text)
            
            if records:
                all_data.extend(records)
        except Exception as e:
            print(f"\n[WARNING] Could not process file '{filename}'. Error: {e}")

    if not all_data:
        print("\n[ERROR] No data could be extracted. The output file will not be created.")
        print("Please check if Tesseract is installed correctly and if the images are clear.")
        return
        
    print(f"\n[INFO] Successfully extracted {len(all_data)} records.")
    
    # Create a pandas DataFrame
    df = pd.DataFrame(all_data, columns=["Name", "Designation", "Company"])
    
    # Remove any potential duplicates that might arise from overlapping screenshots
    df.drop_duplicates(inplace=True)
    
    print(f"[INFO] After removing duplicates, {len(df)} unique records remain.")

    # Save the DataFrame to an Excel file
    try:
        df.to_excel(output_path, index=False)
        print(f"\n[SUCCESS] All data has been saved to: {output_path}")
    except Exception as e:
        print(f"\n[ERROR] Failed to save Excel file. Error: {e}")


if __name__ == "__main__":
    main()
